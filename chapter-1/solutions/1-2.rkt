#lang racket
(require racket/trace)
(require test-engine/racket-tests)
;; Exercise 1.9
; 1

; (define (+ a b)
;   (if (= a 0)
;       b
;       (inc (+ (dec a) b))))

; 2

; (define (+ a b)
;   (if (= a 0)
;       b
;       (+ (dec a) (inc b))))

;;
(define (inc x) (+ x 1))
(define (dec x) (- x 1))

; Using the substitution model, illustrate the process generated by each procedure in evaluating 
; (+ 4 5). Are these processes iterative or recursive?

;; For 1

; (+ 4 5)
; (inc (+ (dec 4) 5))
; (inc (inc (+ (dec 3) 5)))
; (inc (inc (inc (+ (dec 2) 5))))
; (inc (inc (inc (inc (+ (dec 1) 5)))))
; (inc (inc (inc (inc 5))))
; (inc (inc (inc 6)))
; (inc (inc 7))
; (inc 8)
; 9


;; For 2

; (+ 4 5)
; (+ (dec 4) (inc 5))
; (+ (dec 3) (inc 6))
; (+ (dec 2) (inc 7))
; (+ (dec 1) (inc 8))
; 9


;; Exercise 1.10

(define (A x y)
  (cond ((= y 0) 0)
        ((= x 0) (* 2 y))
        ((= y 1) 2)
        (else (A (- x 1)
                 (A x (- y 1))))))

(A 1 10)
; 1024

(A 2 4)
; 2^(2^(2^4))
; (A 1 (A 2 3))
; (A 1 (A 1 (A 2 2)))
; (A 1 (A 1 (A 1 (A 1 (A 2 1)))))
; (A 1 (A 1 (A 1 (A 1 2))))
; (A 1 (A 1 (A 1 (A 0 (A 1 1)))))
; (A 1 (A 1 (A 1 (A 0 2))))
; (A 1 (A 1 (A 1 4)))
; 4 -> 2^4
; (A 1 (A 1 (A 0 (A 1 3))))
; (A 1 (A 1 (A 0 (A 0 (A 1 2)))))
; (A 1 (A 1 (A 0 (A 0 (A 0 (A 1 1))))))
; (A 1 (A 1 (A 0 (A 0 (A 0 2)))))
; (A 1 (A 1 (A 0 8))))
; (A 1 (A 1 16)))
; 16 -> 2^16
; .
; .
; .
; (A 1 2^16)
; .
; .
; .
; 2^(2^16)
65536


(A 3 3)
; (A 2 (A 3 2))
; (A 2 (A 2 (A 3 1)))
; (A 2 (A 2 2))
; (A 2 4)
65536

(define (f n) (A 0 n))

(define (g n) (A 1 n))

(define (h n) (A 2 n))

(define (k n) (* 5 n n))

; (f n)
; (A 0 n)
; (* 2 n)


; (g n)
; (A 1 n)
; (A (- 1 1) (A 1 (- n 1)))
; (A (- 1 1) (A (- 1 1) (A 1 (- (- n 1) 1))))
; (A (- 1 1) (A (- 1 1) (A 1 (A 1 (- (- (- n 1) 1) 1)))))
; .
; .
; .
; 2^n

; (h n)
; (A 2 n)
; (A (- 2 1) (A 2 (- n 1)))
; (A (- 2 1) (A (- 2 1) (A 2 (- (- n 1) 1))))
; .
; .
; .
; (A............ (A (- 2 1) (A 2 1))
; (A............ (A (- 2 1) 2))
; (A............ (A (- (- 2 1) 1) (A (- 2 1) (- 2 1))))
; (A............ (A (- (- 2 1) 1) 2))
; (A............ (A (- 2 1) (A 0 2)))
; (A............ (A 1 4))
; (A............ (A (- 1 1) (A 1 (- 4 1))))
; (A............ (A (- 1 1) (A (- 1 1) (A 1 (- (- 4 1) 1)))))
; (A............ (A (- 1 1) (A (- 1 1) (A (- 1 1) (A 1 (- (- 4 1) 1))))))
; (A............ (A (- 1 1) (A (- 1 1) (A (- 1 1) (A (- 1 1) (A 1 (- (- (- 4 1) 1) 1)))))))
; (A............ (A (- 1 1) (A (- 1 1) (A (- 1 1) (A (- 1 1) (A 1 1))))))
; (A............ (A (- 1 1) (A (- 1 1) (A (- 1 1) (A (- 1 1) 2)))))
; (A............ (A (- 1 1) (A (- 1 1) (A (- 1 1) 4))))
; (A............ (A (- 1 1) (A (- 1 1) 8)))
; (A............ (A (- 1 1) 16))
; (A............ (A (- 2 1) 32))
; (A............ (A (- 2 1) 32))
; .
; .
; .

; (g n)
; (A 1 n)

; (g 2) -> (A 1 2) -> 2^2 -> (pow 2 2)
; (g 3) -> (A 1 3) -> 2^3 -> (pow 2 3)
; (g 4) -> (A 1 4) -> 2^4 -> (pow 2 4)

; (pow 2 n)


; (h n)
; (A 2 n)

; (h 2) 2^2 = 4
; (h 3) 2^4 = 16
; (h 4) 2^16 = 65536 = 2^(2^4)

; (h 2) -> (A 2 2) -> 2^2 -> (pow 2 2)- > (pow 2 (A 2 1))
; (h 3) -> (A 2 3) -> 2^4 -> (pow 2 4) -> (pow 2 (A 2 2)) -> (pow 2 (pow 2 2))
; (h 4) -> (A 2 4) -> 2^16 -> (pow 2 16) -> (pow 2 (A 2 3)) -> (pow 2 (pow 2 4)) -> (pow 2 (pow 2 (pow 2 2)))

; (pow (pow 2 (pow 2 2)))
; (h n) = (pow 2 (h (- n 1)))

; (k n)
; (* 5 (pow n 2))

;; 1.2.2 Fibonacci
(define (fib n)
  (fib-iter 1 0 n))

(define (fib-iter a b count)
  (if (= count 0)
      b
      (fib-iter (+ a b) a (- count 1))))

;; It's the iterative way to solve the problem 

(fib 10)

;; Example: Counting change

(define (count-change amount)
  (cc amount 5))

(define (cc amount kinds-of-coins)
  (cond ((= amount 0) 1)
        ((or (< amount 0) (= kinds-of-coins 0)) 0)
        (else (+ (cc amount
                     (- kinds-of-coins 1))
                 (cc (- amount
                        (first-denomination kinds-of-coins))
                     kinds-of-coins)))))

(define (first-denomination kinds-of-coins)
  (cond ((= kinds-of-coins 1) 1)
        ((= kinds-of-coins 2) 5)
        ((= kinds-of-coins 3) 10)
        ((= kinds-of-coins 4) 25)
        ((= kinds-of-coins 5) 50)))

(count-change 100)
(count-change 11)

;; Exercise 1.11

;; by means of recursive process:

(define (func-r-11 n)
    (if (< n 3)
        n
        (+ (func-r-11 (- n 1)) (* 2 (func-r-11 (- n 2))) (* 3 (func-r-11 (- n 3))))))

;; by means of iterative process:
(define (func-i-11 n)
    (if (< n 3)
        n
        (func-i-helper 2 1 0 n)))

(define (func-i-helper x y z n)
    (cond ((= n 0) 0)
          ((< n 4) (+ x (* 2 y) (* 3 z)))
          (else (func-i-helper (+ x (* 2 y) (* 3 z)) x y (- n 1)))))

(func-i-11 3)
(check-expect (= (func-r-11 0) (func-i-11 0)) #t)
(check-expect (= (func-r-11 2) (func-i-11 2)) #t)
(check-expect (= (func-r-11 15) (func-i-11 15)) #t)
(check-expect (= (func-r-11 30) (func-i-11 30)) #t)
(test)

;; Exercise 1.12

; Initlialize a 2d array, L[n, n]
; for i from 1 - > n
;   for j from 1 -> i
;         if i = 1:
;             L[i][j] = 1;
;         else if j = 1 or j = i:
;             L[i][j] = 1;
;         else:
;             L[i][j] = L[i-1][j - 1] + L[i-1][j + 1]
;         endif
;     endfor
; endfor

; psedo code above but it's iterative process

(define (pascal n)

    (define (pascal-calc i j)
        (if (or (= i 1) (= i j) (= j 1))
        1
        (+ (pascal-calc (- i 1) (- j 1)) (pascal-calc (- i 1) j))))

    (define (pascal-row i)
        (define (col-iter j)
            (begin
                (display (pascal-calc i j))
                (display " ")
                (if (= j i)
                    (printf "~n")
                    (col-iter (+ j 1)))))
        (col-iter 1))

    (define (gap-filler i)
        (if (= i n)
            (display "")
            (gap-filler-helper (- n i))))

    (define (gap-filler-helper i)
        (if (= i 0)
            (display "")
            (begin (display " ")
                (gap-filler-helper (- i 1)))))

    (define (pascal-iter i)
        (gap-filler i)
        (pascal-row i)
        (if (= i n)
            (display "")
            (pascal-iter (+ i 1))))

    (pascal-iter 1))

; https://docs.racket-lang.org/reference/Byte_and_String_Output.html#%28def._%28%28quote._~23~25kernel%29._newline%29%29

(pascal 10)

;; Exercise 1.13

; (define (fib n)
;   (cond ((= n 0) 0)
;         ((= n 1) 1)
;         (else (+ (fib (- n 1))
;                  (fib (- n 2))))))

; (define (fib n)
;   (fib-iter 1 0 n))

; (define (fib-iter a b count)
;   (if (= count 0)
;       b
;       (fib-iter (+ a b) a (- count 1))))

; Fib(n) = 0                          if n = 0
;        = 1                          if n = 1
;        = Fib(n - 1) + Fib(n - 2)    otherwise

(define a (/ (+ 1 (sqrt 5)) 2))
(define b (/ (- 1 (sqrt 5)) 2))

; When Fib(0) = 0, then (/ (- (pow a n) (pow b n)) (sqrt 5)) = 0 = Fib(0)
; When Fib(1) = 1, then (/ (- (pow a n) (pow b n)) (sqrt 5)) = (/ (sqrt 5) (sqrt 5)) = Fib(1)
; Assume Fib(n) = (/ (- (pow a n) (pow b n)) (sqrt 5)), 
; which means Fib(n - 1) + Fib(n - 2) = Fib(n) = (/ (- (pow a n) (pow b n)) (sqrt 5))
; Then Fib(n + 1) = Fib(n) + Fib(n - 1)
; Omiited the induction process which I just prestend in the paper...

;; Exercise 1.14
;; steps: \theta(n^2)
;; spaces: \theta(n^2)

;; Exercise 1.15

; (define (cube x) (* x x x))
; (define (p x) (- (* 3 x) (* 4 (cube x))))
; (define (sine angle)
;    (if (not (> (abs angle) 0.1))
;        angle
;        (p (sine (/ angle 3.0)))))

; (sine 12.15)

;; a. ceiling of log_{3.0}(121.5)
;; b. constant * log_{3.0}(10 * a) + 1  steps: \theta(log_a)
;;                                      space: \theta(log_a)

;; Exercise 1.16
; Design a procedure that evolves an iterative exponentiation process that uses successive squaring 
; and uses a logarithmic number of steps, as does fast-expt. (Hint: Using the observation that 
; (b^{n/2})^2 = (b^2)^{n/2}, keep, along with the exponent n and the base b, an additional state 
; variable a, and define the state transformation in such a way that the product a bn is unchanged 
; from state to state. At the beginning of the process a is taken to be 1, and the answer is given 
; by the value of a at the end of the process. In general, the technique of defining an invariant 
; quantity that remains unchanged from state to state is a powerful way to think about the design of 
; iterative algorithms.)

(define (even? n)
  (= (remainder n 2) 0))

(define (fast-expt b n)
    (if (= n 0) 
        1
        (fast-expt-iter b n b 1)))

(define (fast-expt-iter b counter product counter-d)
    (define (square i)
        (* i i))

    (define (d-helper i n product)
        (if (= n 0)
            product 
            (d-helper i (- n 1) (* i product))))

    (cond 
        ((= counter 1) 
            (if (= counter-d 0)
                product
                (* (d-helper counter-d counter-d 1) product)))
        ((even? counter) (fast-expt-iter b 
                        (/ counter 2)
                        (square product)
                        counter-d))
        ; (else (fast-expt-iter b (/ (- counter 1) 2) (* b (square product))))
        (else (fast-expt-iter b (- counter 1) product (+ 1 counter-d)))
         )
    (display product)
    (newline))

; (fast-expt 2 9)
; (fast-expt 2 10)

; (check-expect (fast-expt -2 10) 1024)
; (check-expect (fast-expt 0 1) 0)
; (check-expect (fast-expt 1 8) 1)
; (check-expect (fast-expt 2 8) 256)
; (check-expect (fast-expt 2 10) 1024)
; (check-expect (fast-expt 2 9) 512)
; (test)